# Copyright (C) 2019 Thomas Hess <thomas.hess@udo.edu>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from argparse import ArgumentParser
from pathlib import Path
from typing import NamedTuple, Optional, List

import av1transcoder.constants

__all__ = [
    "Namespace",
    "generate_argument_parser",
    "parse_args",
]


class Namespace(NamedTuple):
    """Mocks the namespace generated by the ArgumentParser. Used for type checking"""
    input_files: List[Path]
    output_dir: Optional[Path]
    temp_dir: Optional[Path]
    keep_temp: bool
    force_overwrite: bool

    scene_cut_threshold: float
    min_scene_length: int
    max_scene_length: int
    enable_single_pass_encode: bool
    encoder_parameters: str
    global_parameters: str
    max_concurrent_encodes: int
    deinterlace: bool
    dump_commands: str

    verbose: bool
    cutelog_integration: bool
    ffmpeg: str
    ffprobe: str
    ffmpeg_base: Optional[str]


def generate_argument_parser() -> ArgumentParser:
    """
    Generates the argument parser.
    :return: ArgumentParser instance
    """
    description = "Transcode video files to AV1. This program takes input video files and transcodes the video track " \
                  "to the AV1 format using the libaom-av1 reference encoder."
    epilog = "The resulting files are named like <input_file_name>.AV1.mkv and are placed alongside the input file, " \
             "or into the output directory given by --output-dir. During the encoding process, each input file will " \
             "have it’s own temporary directory named <input_file_name_with_extension>.temp. " \
             "The temporary directory is placed according to the placement rules, preferring --temp-dir over " \
             "--output-dir over the input file’s directory. " \
             "The output files will only contain video tracks. You have to add back other tracks yourself, " \
             "like audio or subtitles, and mux them into the container of your choice. " \
             "Files with multiple video tracks are untested and probably won’t work. Filenames that contain esoteric " \
             "characters like newlines will probably break the ffmpeg concat demuxer and will likely cause failures."
    parser = ArgumentParser(description=description, epilog=epilog)
    parser.add_argument(
        "input_files", action="store", type=Path, metavar="input_file", nargs="+",
        help="Input video files. All given video files will be transcoded to AV1."
    )
    parser.add_argument(
        "-o", "--output-dir", action="store", type=Path,
        help="Store the result in this directory. If set and --temp-dir is unset, also store the temporary data here. "
             "If unset, results are stored alongside the input file."
    )
    parser.add_argument(
        "-t", "--temp-dir", action="store", type=Path,
        help="Store temporary data in this directory. If unset, use the output directory set by --output-dir. If "
             "that is unset, store the temporary data alongside the input data."
    )
    parser.add_argument(
        "-k", "--keep-temp", action="store_true",
        help="Keep temporary data after the transcoding process finished. May help in resolving transcoding issues."
    )
    parser.add_argument(
        "-f", "--force-overwrite", action="store_true",
        help="Force overwriting existing data. If unset and filename collisions are detected, the affected input files "
             "are skipped. If set, existing files will be overwritten."
    )
    parser.add_argument(
        "-s", "--scene-cut-threshold", action="store", type=float, default=0.5,
        help="Define the threshold value for the scene cut detection filter. "
             "Accepts a decimal number. Defaults to %(default)f"
    )
    parser.add_argument(
        "-m", "--min-scene-length", action="store", metavar="SECONDS", type=int, default=30,
        help="Minimal allowed scene duration in seconds. "
             "Adjacent detected scenes are combined to have at least this duration, if possible. "
             "This is not a hard limit. It prevents splitting the input video into many small and "
             "independent encoding tasks to improve encoding efficiency. Defaults to %(default)i"
    )
    # TODO: The logic to convert PTS needs to be implemented
    # parser.add_argument(
    #     "-M", "--max-scene-length", action="store", metavar="SECONDS", type=int, default=120,
    #     help="Maximal allowed scene duration in seconds. Longer scenes are split to not exceed this limit. "
    #          "Defaults to %(default)i"
    # )
    parser.add_argument(
        "-1", "--single-pass", action="store_true", dest="enable_single_pass_encode",
        help="Use Single-Pass encoding instead of Two-Pass encoding. Custom encoder parameters are always passed to "
             "ffmpeg for all encoding passes."
    )
    parser.add_argument(
        "-e", "--encoder-parameters", action="store", metavar="STRINGS",
        # Maybe:
        # default="-cpu-used 4 -crf 20 -row-mt 1 -frame-parallel 0 -tiles 2x2 -tile-columns 1 -tile-rows 1 -threads 0"
        # As of writing this, tiles can produce corrupted frames, so disable default tile usage for now.
        # To have more consistent CPU utilization, disable ffmpeg-internal threading and rely on our -c parameter only.
        default="-cpu-used 4 -crf 20 -frame-parallel 0 -threads 1",
        help="Add custom encoder parameters to the encoding process. Add all parameters as a single, quoted string. "
             "These parameters will be passed directly to all ffmpeg processes doing the encoding work. As an example, "
             "the default value is '%(default)s'. Due to a bug in Python argument parser "
             "(https://bugs.python.org/issue9334), the parameters MUST NOT begin with a dash (-) when used as "
             "--encoder-parameters \"<parameters>\". You MUST either begin the quoted custom parameter string with a "
             "space character or use = to specify the string, like --encoder-parameters=\"-your-parameters-here\""
    )
    parser.add_argument(
        "-g", "--global-parameters", action="store", metavar="STRINGS", default="",
        help="Add custom global parameters to all ffmpeg processes. These are passed in as the first arguments to "
             "ffmpeg before the input file and can be used to enable hardware acceleration or similar global switches. "
             "Example: '-hwaccel cuvid'. "
             "Default is to add no parameters at all, leaving everything at the default settings. BEWARE: The issue "
             "described for --encoder-parameters applies here, too."
    )
    parser.add_argument(
        "-c", "--max-concurrent-encodes", action="store", type=int, default=8,
        help="Run up to this many ffmpeg instances in parallel. As of writing this, libaom-av1 is bad at scaling "
             "horizontally, so encode this many video scenes independently and parallel to increase system load and "
             "decrease encoding time. Defaults to %(default)i"
    )
    parser.add_argument(
        "--dump-commands", action="store", choices=["yes", "no", "only"], default="no",
        help="Dump executed ffmpeg commands in text files for later examination or manual execution. The files will "
             "be placed in the temporary directory. If set to 'only', "
             "this program will only dump the command lines but not actually execute encoding tasks. The scene "
             "detection will always be executed even if set to 'only', "
             "because the later steps require the data to be present. "
             "Defaults to '%(default)s'. Setting to a non-default value implies setting '--keep-temp'."
    )
    parser.add_argument(
        "--deinterlace", action="store_true",
        help="Deinterlace the interlaced input video using the yadif video filter."
    )
    parser.add_argument(
        "-v", "--version", action="version",
        version=f"{av1transcoder.constants.PROGRAMNAME} Version {av1transcoder.constants.VERSION}"
    )
    parser.add_argument(
        "-V", "--verbose",
        action="store_true",
        help="Increase output verbosity. Also show debug messages on the standard output."
    )
    parser.add_argument(
        "--cutelog-integration",
        action="store_true",
        help="Connect to a running cutelog instance with default settings to display the full program log. "
             "See https://github.com/busimus/cutelog"
    )
    parser.add_argument(
        "--ffmpeg",
        default="ffmpeg", metavar="EXECUTABLE_NAME",
        help="Specify the ffmpeg executable name. "
             "Can be a relative or absolute path or a simple name. If given a simple name, the system "
             "PATH variable will be searched. Defaults to \"%(default)s\""
    )
    parser.add_argument(
        "--ffprobe",
        default="ffprobe", metavar="EXECUTABLE_NAME",
        help="Specify the ffprobe executable name. "
             "Can be a relative or absolute path or a simple name. If given a simple name, the system "
             "PATH variable will be searched. Defaults to \"%(default)s\""
    )
    parser.add_argument(
        "--ffmpeg-base",
        default=None,
        metavar="DIRECTORY",
        help="Specify the path to a custom ffmpeg installation. If given, both --ffmpeg and --ffprobe "
             "arguments are treated as a path relative to this path."
    )
    return parser


def parse_args() -> Namespace:
    """
    Generates the argument parser and use it to parse the command line arguments.
    :return: Parsed command line arguments
    """
    args: Namespace = generate_argument_parser().parse_args()
    if args.dump_commands != "no":
        args.keep_temp = True
    return args
